// --------------------------------------------------------------------------------
// Name: FQuickExploit
// Abstract: Launches a quick exploit against a target
// --------------------------------------------------------------------------------

// Includes
import java.io.*;
import java.util.*;
import java.util.Timer;
import javax.swing.*;
import javax.swing.event.*;
import org.w3c.dom.*;
import java.awt.event.*;

public class FQuickExploit extends CAircrackWindow implements DocumentListener, MouseListener
{
	protected final static long serialVersionUID = 1L;
	
	private enum udtCacheCreationType
	{
		CACHE_CREATION_CACHE_EXISTS,
		CACHE_CREATION_BUILD_CACHE,
		CACHE_CREATION_DONT_USE_CACHE
	}
	
	private CProcess m_clsMSFConsole = null;
	private BufferedReader m_brMSFConsoleOutput = null;
	
	private CTabContainer m_tcTabContainer = null;
	
	private CTable m_tblAvailableExploits = null;
	private CTable m_tblAvailableAuxiliary = null;
	
	private JLabel m_lblStatusLabel = null;
	private CTextBox m_txtSearchBox = null;
	
	// --------------------------------------------------------------------------------
	// Name: FQuickExploit
	// Abstract: Class constructor
	// --------------------------------------------------------------------------------
	public FQuickExploit( )
	{
		super("Quick Exploit", 640, 480, false, false, "");
		try
		{
			udtCacheCreationType udtCacheCreation = CheckForCachedOutput( );
			AddControls( );
			CreateMetasploitConsoleProcess( udtCacheCreation );
			CheckForCachedOutput();
		}
		catch (Exception excError)
		{
			CUtilities.WriteLog( excError );
		}
	}

	// --------------------------------------------------------------------------------
	// Name: CheckForCachedOutput
	// Abstract: Checks for a NGUI Metasploit cache to rely from instead of using the slow
	//			 msfcli command.
	// --------------------------------------------------------------------------------
	private udtCacheCreationType CheckForCachedOutput( )
	{
		udtCacheCreationType udtCacheCreation = udtCacheCreationType.CACHE_CREATION_DONT_USE_CACHE;
		try
		{
			File filCacheFile = new File("Metasploit.cache");
			Date dtmCurrentDate = new Date( );
			
			if ( filCacheFile.exists( )== true )
			{
				udtCacheCreation = udtCacheCreationType.CACHE_CREATION_CACHE_EXISTS;
				
				Date dtmLastModified = new Date(filCacheFile.lastModified());
				int intDifference = dtmCurrentDate.getDate( ) - dtmLastModified.getDate( );
				
				// Convert the difference from milliseconds to days
				intDifference /= (1000 * 60 * 60 * 24);
				
				if ( intDifference > 5 )
				{
					int intRebuildCache = JOptionPane.showConfirmDialog(null, "Your Metasploit cache is older than 5 days. Do you want to rebuild it?", "Aircrack-NGUI", JOptionPane.YES_NO_OPTION);
					if ( intRebuildCache == JOptionPane.YES_OPTION )
					{
						filCacheFile.delete( );
						udtCacheCreation = udtCacheCreationType.CACHE_CREATION_BUILD_CACHE;
					}
				}
			}
			else
			{
				udtCacheCreation = udtCacheCreationType.CACHE_CREATION_BUILD_CACHE;
				int intBuildCache = JOptionPane.showConfirmDialog(null, "We detected that you haven't created a Metasploit cache so you can use this form faster.\nDo you want to create a cache now?", "Aircrack-NGUI", JOptionPane.YES_NO_OPTION);
				if ( intBuildCache == JOptionPane.NO_OPTION )
				{
					udtCacheCreation = udtCacheCreationType.CACHE_CREATION_DONT_USE_CACHE;
				}
			}
		}
		catch (Exception excError)
		{
			CUtilities.WriteLog( excError );
		}
		return udtCacheCreation;
	}
	
	// --------------------------------------------------------------------------------
	// Name: AddControls
	// Abstract: Adds the controls onto the form
	// --------------------------------------------------------------------------------
	private void AddControls( )
	{
		try
		{
			
			m_tcTabContainer = CUtilities.AddTabContainer(m_cntControlContainer, 5, 5, 415, 625);
			
			JPanel pnlQuickExploit = m_tcTabContainer.AddTab("Quick Exploit");
			JPanel pnlQuickAuxiliary = m_tcTabContainer.AddTab("Quick Auxiliary");
			
			m_tblAvailableExploits = CUtilities.AddTable(pnlQuickExploit, new String[] {"Name", "Description"}, null, 5, 5, 380, 610);
			m_tblAvailableAuxiliary= CUtilities.AddTable(pnlQuickAuxiliary, new String[] {"Name", "Description"}, null, 5, 5, 380, 610);
			
			m_tblAvailableExploits.SetReadOnly( true );
			m_tblAvailableExploits.SetMouseListener( this );
			
			m_tblAvailableAuxiliary.SetReadOnly( true );
			m_tblAvailableAuxiliary.SetMouseListener( this );
			
			m_lblStatusLabel = CUtilities.AddLabel(m_cntControlContainer, "Launching MSF console...", 425, 5);
			
			CUtilities.AddLabel(m_cntControlContainer, "Search:", 425, 400);
			m_txtSearchBox = CUtilities.AddTextBox(m_cntControlContainer, this, "", 15, 200, 423, 460);
			m_txtSearchBox.setEnabled( false );
			m_txtSearchBox.addActionListener( this );
			
		}
		catch (Exception excError)
		{
			CUtilities.WriteLog( excError );
		}
	}

	// --------------------------------------------------------------------------------
	// Name: CreateMetasploitConsoleProcess
	// Abstract: Creates the MSFConsole process
	// --------------------------------------------------------------------------------
	private void CreateMetasploitConsoleProcess( udtCacheCreationType udtCacheCreation )
	{
		try
		{
			
			if ( udtCacheCreation == udtCacheCreationType.CACHE_CREATION_CACHE_EXISTS )
			{
				CXMLReader clsCacheFile = new CXMLReader( );
				clsCacheFile.LoadXMLIntoMemory("Metasploit.cache");
				Node ndlRootNode = clsCacheFile.GetRootElement( );
				NodeList ndlExploitTypes = ndlRootNode.getChildNodes( );
				for ( int intIndex = 0; intIndex < ndlExploitTypes.getLength( ); intIndex += 1 )
				{
					Node ndlCurrentNode = ndlExploitTypes.item( intIndex );
					NodeList ndlCurrentNodeChildren = ndlCurrentNode.getChildNodes( );
					for ( int intIndex2 = 0; intIndex2 < ndlCurrentNodeChildren.getLength( ); intIndex2 += 1 )
					{
						Element eleCurrentGrandchild = (Element)ndlCurrentNodeChildren.item( intIndex2 );
						String strExploitName = eleCurrentGrandchild.getAttribute("Name");
						String strExploitDescription = eleCurrentGrandchild.getAttribute("Description");
						if ( ndlCurrentNode.getNodeName( ).equals("Exploits") )
						{
							m_tblAvailableExploits.AddRow(new Object[] {strExploitName, strExploitDescription});
						}
						else if ( ndlCurrentNode.getNodeName( ).equals("Auxiliaries") )
						{
							m_tblAvailableAuxiliary.AddRow(new Object[] {strExploitName, strExploitDescription});
						}
					}
				}
				m_txtSearchBox.setEnabled( true );
				m_lblStatusLabel.setText( "Done." );
			}
			else
			{
				m_clsMSFConsole = new CProcess(new String[] {"msfcli"}, true, false, true);
				Thread.sleep( 250 ); // Give the process some time to start
				m_brMSFConsoleOutput = new BufferedReader( m_clsMSFConsole.GetOutput( ) );
				
				boolean blnCreateCache = false;
				if ( udtCacheCreation == udtCacheCreationType.CACHE_CREATION_DONT_USE_CACHE )
					blnCreateCache = false;
				else if ( udtCacheCreation == udtCacheCreationType.CACHE_CREATION_BUILD_CACHE )
					blnCreateCache = true;
				Timer timStartProcess = new Timer( );
				timStartProcess.schedule( new CReadyForInput( blnCreateCache ), 100 );
			}
		}
		catch (Exception excError)
		{
			CUtilities.WriteLog( excError );
		}
	}

	// --------------------------------------------------------------------------------
	// Name: CReadyForInput
	// Abstract: Monitors the MSFConsole process to notify when it's ready for input
	// --------------------------------------------------------------------------------
	private class CReadyForInput extends TimerTask
	{
		boolean m_blnCreateCache;
		
		public CReadyForInput( boolean blnCreateCache )
		{
			m_blnCreateCache = blnCreateCache;
		}
		
		// --------------------------------------------------------------------------------
		// Name: run
		// Abstract: Called when the TimerTask is executed
		// --------------------------------------------------------------------------------
		public void run( )
		{
			try
			{
				
				String strBuffer = m_brMSFConsoleOutput.readLine( );
				boolean blnLoadingExploits = false;
				boolean blnLoadingAuxiliary = false;
				String strExploitName = "";
				String strExploitDescription = "";
				CXMLWriter clsNewDocument = new CXMLWriter( );
				Element eleMetasploitCache = clsNewDocument.AddRootNode("MetasploitCache");
				Element eleExploits = clsNewDocument.AddChildNode("Exploits", eleMetasploitCache);
				Element eleAuxiliaries = clsNewDocument.AddChildNode("Auxiliaries", eleMetasploitCache);
				Element eleNewNode = null;
				
				boolean blnDontRunAgain = false;
				while ( strBuffer != null )
				{
					blnDontRunAgain = true;
					if ( strBuffer.contains( "Please wait while we load the module tree..." ) == true )
						m_lblStatusLabel.setText("Please wait while we load the module tree...");
					
					if ( strBuffer.contains("====") == false && (blnLoadingExploits == true || blnLoadingAuxiliary == true) )
					{
						if ( strBuffer.equals("") == false && 
								strBuffer.trim( ).startsWith("Name") == false && 
								strBuffer.contains("----") == false &&
								strBuffer.trim( ).startsWith("Auxiliary") == false )
						{
							strBuffer = strBuffer.trim( );
							if ( blnLoadingExploits == true )
							{
								strExploitName = strBuffer.substring(0, 71).trim( );
								strExploitDescription = strBuffer.substring( 71 ).trim( );
								m_tblAvailableExploits.AddRow(new Object[] {strExploitName, strExploitDescription});
								
								eleNewNode = clsNewDocument.AddChildNode("Exploit", eleExploits);
								clsNewDocument.AddAttributeToNode(eleNewNode, "Name", strExploitName);
								clsNewDocument.AddAttributeToNode(eleNewNode, "Description", strExploitDescription);
							}
							else if ( blnLoadingAuxiliary == true )
							{
								strExploitName = strBuffer.substring(0, 73).trim( );
								strExploitDescription = strBuffer.substring( 73 ).trim( );
								m_tblAvailableAuxiliary.AddRow(new Object[] {strExploitName, strExploitDescription});
								
								eleNewNode = clsNewDocument.AddChildNode("Auxiliary", eleAuxiliaries);
								clsNewDocument.AddAttributeToNode(eleNewNode, "Name", strExploitName);
								clsNewDocument.AddAttributeToNode(eleNewNode, "Description", strExploitDescription);
							}
						}
					}
					
					if ( strBuffer.equals("Exploits") == true )
					{
						blnLoadingExploits = true;
						blnLoadingAuxiliary = false;
					}
					
					if ( strBuffer.equals("Auxiliary") == true )
					{
						blnLoadingAuxiliary = true;
						blnLoadingExploits = false;
						m_txtSearchBox.setEnabled( true );
						m_lblStatusLabel.setText( "Done." );
					}
					
					strBuffer = m_brMSFConsoleOutput.readLine( );
					
				}
				
				if ( m_blnCreateCache == true )
					clsNewDocument.SaveXMLToDisk("Metasploit.cache");
				
				if ( blnDontRunAgain == false )
				{
					Timer timStartProcess = new Timer( );
					timStartProcess.schedule( new CReadyForInput( m_blnCreateCache ), 100 );
				}
				
			}
			catch (Exception excError)
			{
				CUtilities.WriteLog( excError );
			}
		}
		
	}

	// --------------------------------------------------------------------------------
	// Name: changedUpdate
	// Abstract: Called when a textbox is changed
	// --------------------------------------------------------------------------------
	@Override
	public void changedUpdate(DocumentEvent deSource)
	{
		try
		{
			if ( deSource.getDocument( ) == m_txtSearchBox.getDocument( ) )
			{
				PerformSearch( 0 );
			}
		}
		catch (Exception excError)
		{
			CUtilities.WriteLog( excError );
		}
	}

	// --------------------------------------------------------------------------------
	// Name: insertUpdate
	// Abstract: Called when a textbox is typed in
	// --------------------------------------------------------------------------------
	@Override
	public void insertUpdate(DocumentEvent deSource)
	{
		try
		{
			if ( deSource.getDocument( ) == m_txtSearchBox.getDocument( ) )
			{
				PerformSearch( 0 );
			}
		}
		catch (Exception excError)
		{
			CUtilities.WriteLog( excError );
		}	
	}

	// --------------------------------------------------------------------------------
	// Name: removeUpdate
	// Abstract: Called when data is removed from a textbox
	// --------------------------------------------------------------------------------
	@Override
	public void removeUpdate(DocumentEvent deSource)
	{
		try
		{
			if ( deSource.getDocument( ) == m_txtSearchBox.getDocument( ) )
			{
				
				PerformSearch( 0 );
			}
		}
		catch (Exception excError)
		{
			CUtilities.WriteLog( excError );
		}
	}

	// --------------------------------------------------------------------------------
	// Name: PerformSearch
	// Abstract: Searches for an exploit with the typed text in either its name or
	//			 description.
	// --------------------------------------------------------------------------------
	private void PerformSearch( int intStartingIndex )
	{
		try
		{
			String strExploitName = "";
			String strExploitDescription = "";
			int intSelectedIndex = -1;
			String strSearchCriteria = m_txtSearchBox.getText( ).trim( );

			CTable tblSearchedTable = null;
			if ( m_tcTabContainer.GetJTabbedPane( ).getSelectedIndex( ) == 0 )
				tblSearchedTable = m_tblAvailableExploits;
			else if ( m_tcTabContainer.GetJTabbedPane( ).getSelectedIndex( ) == 1 )
				tblSearchedTable = m_tblAvailableAuxiliary;
			
			if ( intStartingIndex > tblSearchedTable.GetRowCount( ) )
				intStartingIndex = 0;
			
			if ( m_txtSearchBox.getText( ).trim( ).equals( "" ) == false )
			{
				for ( int intIndex = intStartingIndex; intIndex < tblSearchedTable.GetRowCount( ); intIndex += 1 )
				{
					
					strExploitName = String.valueOf(tblSearchedTable.GetCellValue(intIndex, "Name"));
					strExploitDescription = String.valueOf(tblSearchedTable.GetCellValue(intIndex, "Description"));
					
					if ( strExploitName.contains( strSearchCriteria ) || strExploitDescription.contains( strSearchCriteria ) )
						intSelectedIndex = intIndex;
					
					if ( intSelectedIndex != -1 )
						break;
				}
				
				if ( intSelectedIndex != -1 )
					tblSearchedTable.SetSelectedIndex( intSelectedIndex );
			}
			else
			{
				tblSearchedTable.SetSelectedIndex( 0 );
			}
		}
		catch (Exception excError)
		{
			CUtilities.WriteLog( excError );
		}
	}

	// --------------------------------------------------------------------------------
	// Name: mouseClicked
	// Abstract: Handles mouse clicks
	// --------------------------------------------------------------------------------
	@Override
	public void mouseClicked(MouseEvent meSource)
	{
		try
		{
			if ( meSource.getSource( ) == m_tblAvailableExploits.GetTable( ) )
				tblAvailableExploits_MouseClick( meSource.getClickCount( ) );
			else if ( meSource.getSource( ) == m_tblAvailableAuxiliary.GetTable( ) )
				tblAvailableAuxiliary_MouseClick( meSource.getClickCount( ) );
		}
		catch (Exception excError)
		{
			CUtilities.WriteLog( excError );
		}
	}

	// --------------------------------------------------------------------------------
	// Name: tblAvailableExploits_MouseClick
	// Abstract: Opens up the selected exploit
	// --------------------------------------------------------------------------------
	private void tblAvailableExploits_MouseClick( int intClickCount )
	{
		try
		{
			if ( intClickCount >= 2 )
			{
				String strExploitName = String.valueOf(m_tblAvailableExploits.GetCellValue(m_tblAvailableExploits.GetSelectedRow( ), "Name"));
				DLaunchExploit dlgLaunchExploit = new DLaunchExploit( strExploitName );
				dlgLaunchExploit.setVisible( true );
			}
		}
		catch (Exception excError)
		{
			CUtilities.WriteLog( excError );
		}
	}
	
	// --------------------------------------------------------------------------------
	// Name: tblAvailableAuxiliary_MouseClick
	// Abstract: Opens up the selected exploit
	// --------------------------------------------------------------------------------
	private void tblAvailableAuxiliary_MouseClick( int intClickCount )
	{
		try
		{
			if ( intClickCount >= 2 )
			{
				String strExploitName = String.valueOf(m_tblAvailableAuxiliary.GetCellValue(m_tblAvailableAuxiliary.GetSelectedRow( ), "Name"));
				DLaunchExploit dlgLaunchExploit = new DLaunchExploit( strExploitName );
				dlgLaunchExploit.setVisible( true );
			}
		}
		catch (Exception excError)
		{
			CUtilities.WriteLog( excError );
		}
	}

	// --------------------------------------------------------------------------------
	// Name: tblAvailableAuxiliary_MouseClick
	// Abstract: Opens up the selected exploit
	// --------------------------------------------------------------------------------
	public void actionPerformed(ActionEvent aeSource)
	{
		super.actionPerformed( aeSource );
		try
		{
			if ( m_blnLoading == false )
			{
				if ( aeSource.getSource( ) == m_txtSearchBox )
				{
					int intSelectedTab = m_tcTabContainer.GetJTabbedPane( ).getSelectedIndex( );
					if ( intSelectedTab == 0 )
						PerformSearch( m_tblAvailableExploits.GetSelectedRow( ) + 1 );
					else
						PerformSearch( m_tblAvailableAuxiliary.GetSelectedRow( ) + 1 );
				}
			}
		}
		catch (Exception excError)
		{
			CUtilities.WriteLog( excError );
		}
	}
	
	public void mouseEntered(MouseEvent arg0) {}
	public void mouseExited(MouseEvent arg0) {}
	public void mousePressed(MouseEvent arg0) {}
	public void mouseReleased(MouseEvent arg0) {}
	
}